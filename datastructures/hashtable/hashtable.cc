/**
 * 一、散列思想
 *     通过散列函数通过 Key 值计算得出数组下标，然后利用数组支持下标随机访问的特性，
 * 在时间复杂度为O(1)的情况下找到所需要的信息。
 * 
 *              散列函数
 *       Key -------------> 散列值（哈希值）
 *            （哈希函数）
 * 
 * 二、散列函数
 *     顾名思义，其是一个函数，函数原型大概如下：
 *          size_t hash(key);
 *     要求，
 *      1、散列值是非负整数。
 *      2、若 key1 = key2，则 hash(key1) == hash(key2) 。
 *      3、若 key1 != key2，则 hash(key1) != hash(key2) 。
 * 拓展，哈希算法：MD5、SHA、CRC。
 * 
 * 三、散列冲突
 * 定义：当 key1 != key2 时，hash(key1) == hash(key2) 。
 * 解决办法：
 * 1、开放寻址法
 * 定义：当出现散列冲突时，在数组中重新探测一个空闲位置，将数据插入到该位置中。
 * （1）线性探测（Linear Probing）
 *      a、冲突之后，从当前位置依次向后查找（步长为1），直到找到空闲位置将数据插入到该位置。
 *      b、上述操作之后没有发现空闲位置，则从数组的起始位置开始查找空闲位置。
 * （2）二次探测
 *      与线性探测类似，唯一的不同点，线性探测探测步长为1，而二次探测的探测
 *  步长是当前步长的2次方。
 * （3）双重散列
 *      存在多个散列函数，当其中一个函数出现了散列冲突，则使用第2个散列函数，
 *  依次类推，直到不存在散列冲突位置。
 * 2、链表法（常用）
 *      在散列表中每一项不再存放数据，而是存放一个链表的首地址，该链表存放与该
 *  散列值相同的数据。
 *      时间复杂度就是这些链表的长度，假设为k，时间复杂度为 O(k) 。
 * 
 * 四、装载因子（load factor）
 *      装载因子 = 填入表中的元素个数 / 散列表的长度 。
 *      装载因子越大，则空闲位置越少，冲突越多，散列表的性能就越低，
 *  时间复杂度最坏情况从 O(1) 降到 O(n) 。
 * 
 * 五、散列表碰撞攻击的原理
 *      对于使用链表法解决散列冲突的散列表，攻击者精心制作数据，使得这些数据
 *  全部都散列到散列表同一个位置，导致散列表退化为链表，时间复杂度直接将为了
 *  O(n)。查询的过程中直接导致CPU资源耗尽，导致服务器无法相应其他需求。
*/